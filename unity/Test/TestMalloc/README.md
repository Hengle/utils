#优化的原理：

在片段着色器中，我以正常cpu编程的逻辑进行了优化，例如，if(edge<_Edge){return _EdgeColor;}，如果此像素被判定为边缘，则直接返回边缘颜色，那么则不用再进行之后的运算了。以此类推后面又用if else 分别进行了高光，亮光，暗光区的判断。但是这种优化对于gpu编程来讲是无效的。因为对于GPU来讲，各个顶点各个像素都在进行大量的并行运算，每个片段着色器都在同步运行，边缘地带像素的片段着色器虽然率先return，但是它依然要等待最后一个return的像素。只有所有像素全部完成计算，才会进行下一次运算， 在片段着色器中，每个片段处理器每条指令操作上百个像素，如果有些片段（像素）采取一个分支而有些片段不采用另一个分支，则所有片段都会执行两个分支，但只在每个片段应该采取的分支上写入寄存器。另外，if/endif等流程控制操作有较高的开销（4个时钟周期,Geforce6）修改1修改1。因此在GPU编程中，if else ，switch case等条件语句和太复杂的逻辑是不推荐的。相应的，可以用step（）等函数进行替换，用阶梯函数的思维来构建条件语句。这样，所有的线程都执行完全一样的代码，在很多方面对GPU都是有益的。

1.复杂的数学函数（如 pow，exp，log，cos，sin，tan 等等）会大大增加 GPU 负担，所以一个好的经验法则是，此类运算在每个像素中不得超过一个。考虑在合适时使用查找纹理作为替代选择。

2.alpha 测试运算会让片段速度变慢。（on PowerVR GPUs found in iOS and some Android devices）

3.编写自定义的着色器时，应始终指定浮点变量精度。为获得最佳性能，挑选精度尽可能小的浮点格式至关重要。很多台式机 GPU 均完全忽略运算精确，但是它对于大量移动 GPU 的性能具有重大影响。

如果着色器使用 Cg/HLSL 编写，那么精度规定如下：

float — 完整的 32 位浮点格式，适合用于顶点变换，但性能最慢。
half — 简化的 16 位浮点格式，适用于纹理 UV 坐标且比 float 大约快两倍。
fixed — 10位定点格式，适合色彩、照明计算和其它高性能操作，速度大约比 float 快 4 倍
 
 
